# microservices as controllers

## HTTPのリクエストの処理に対する前提

HTTPは素晴らしいプロトコルだと思うが、リクエストに対して同期的にレスポンスを期待する。人がブラウザを使ってサイトを回覧する場合、待てる時間は長くない。だから同期的にレスポンスを期待することは悪くない。しかし、それがweb appの設計を決定づける必要もない。

私は、長くrailsでweb appのbackendを開発していた。最近は、webをインターフェースとしないソフトウェアを書くことが多くなり、そこから色々なことを学んだ。学んだことの全てが新しいことではないし、寧ろ思い出したことも多いのだが、web appの開発から離れてweb appの開発を客観的に見れたのが良かった。当たり前だと思っていたことも、少し距離を置いてみるとそれが当たり前である必要がないことだと気づくことは多い。

多くのweb appの、特にweb appのbackendの設計は、大きな前提を持っている。同期的なレスポンスを返すために、backendの設計も同期的な思想の元に設計されている。どちらかと言えば、railsなどのweb frameworkが、という方が正しいかもしれない。HTTPのリスエストを受け取った時には、リクエストとレスポンスを象徴するオブジェクトを共にメソッドか関数が呼ばれる。必要な処理をして、レスポンスを返す。裏では、各々のリクエストがスレッドやプロセスで処理されていて、その処理を動的に書いても他のリスエストがブロックされることはないことも多い。私が気づいたのは、私自身の中にあった、*"HTTPのリクエストに対する処理は、呼ばれたメソッドや関数の中で完結させる"*、という前提だった。処理の過程でデータベースからデータを読んだり書いたりこそすれど、web frameworkによって呼ばれたメソッドや関数の最後にはレスポンスを返す。これは、nodeを使っていた時も同じだった。処理を非同期的に書いても、コールバックの最後にはレスポンスを返すという前提があった。しかし、この前提は前提である必要はない。

## tighly coupledからloosely coupledへ

*"HTTPのリクエストに対する処理は、呼ばれたメソッドや関数の中で完結させる"*、という前提は、HTTPプロトコルの思想に強く依存している。しかし、HTTPプロトコルそのものは、HTTPのリクエストがどう処理されようが構わない。HTTPのリクエストに対してレスポンスが返ってこれば良いのだ。ならば、*"HTTPのリクエストに対する処理は、呼ばれたメソッドや関数の中で完結させる必要はない"*、という前提の元でHTTPのリクエストを処理してみたらどうなるのだろうか。

今回は、それをmessaging queueを使って実装した。HTTPのサーバがHTTPのリクエストを受け取ったら、HTTPのリクエストを受け取ったというメッセージを流す。このメッセージには、HTTPのリクエストそのものも含まれている。HTTPのリクエストを処理するソフトウェアは、このメッセージをmessaging queueから受け取り、それが自分が処理するべきHTTPのリクエストであればそれを処理する。その処理の最後には、HTTPのリクエストを処理したというメッセージを流す。HTTPのサーバは、このメッセージをmessaging queueから受け取り、HTTPのリクエストに対してHTTPのレスポンスを返す。こうすることで、*"HTTPのリクエストに対する処理は、呼ばれたメソッドや関数の中で完結させる必要はない"*、という前提による実装ができた。







railsだと、通常のリクエストの処理より時間がかかるようなリクエストを処理する場合はsidekiqなどを使う。時間のかかる処理を、ジョブという形でHTTPのリクエストの処理とは違うところで処理する。この場合、HTTPのリクエストは何らかしらのアクションを要求するものの、そのアクションが完了するのはそのアクションを要求したHTTPリクエストに対するレスポンスを返すタイミングではない。この場合、web framworkによって呼ばれるメソッドや関数ですることは、ジョブを作って、HTTPのリクエストに対するレスポンスを返すことのみだ。